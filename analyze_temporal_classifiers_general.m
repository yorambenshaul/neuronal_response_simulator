function analyze_temporal_classifiers_general(class_method,classifier_type,comparison,Ntrain,Ntest,ResampleN,Nrepeats,MaxEpochs,shuffle_method)
% YBS 2017-2018
% Classify responses to different stimuli. 
% This function contains many revisions, and has multiple options for
% sampling the data. In this version, there is no overlap at all between
% training and test data.
%
% class_method: a string, specifying the classification approach:
%        'time sensitive': each time point is regarded as a different input
%        'time invariant': all time points are intermixed  
%        'time invariant more': same as time invariant, but we zoom in on
%        a subset of windows
%
% classifier_type: a string, specifying the classifier type. Currently,
% implemented are:
%        'PERC': linear perceptron classifier
%        'SVM': support vector machine, using a quadratic kernel
%        These options can be easily expanded. There is only one line of
%        code within this function that distinghishes among the options
%
% comparison: A string that detemine the two stimuli to be compared.
%        The options 'MF','MP', and 'FP' denote comparisons between male
%        female, male predator, and female predator stimuli, respectively.
%        Depending on the comparison called, the data will be loaded. Note
%        that the data for each stimulus will comprise 3 different
%        dilutions. Note also that the data directory for these inputs is specified within
%        the program below.
%        If the string is none of these, then it will be interpreted as
%        simulated data, in which we have stimA, and stimB only. 
%        For both real and stimulated data, the data is organized in .mat
%        files, which contain spike counts (or firing rates) in individual
%        windows, with a specific latency and duration, which is indicated
%        by the name of the file. This data is generated by functions that
%        generated for example by
%        call_generate_data_for_temporal_classifiers_V2 or by generate_simulated_classifier_struct_gui 
%
% Ntrain: The number of samples in the training set
%
% Ntest:  The number of samples in the test set
%
%   Note that Ntrain and Ntest must be even number, because the datasets will
%   have equal contributions from both stimulus sets (i.e. stimA and stimB). 
%   Also, Ntrain and Ntest must not exceed the number of trials in the
%   dataset. For example, if we have 10 trials repeats of each stimulus, then
%   the Ntrain + Ntest is limited at 20. For real data, the total number of
%   trials that matters is the sum over all dilutions.
%
% ResampleN: This variable determines the mode of resmapling - called the sampling_method within the code.
%   It can be 0,1, or any number (larger than the actual number of trials)
%   0: there is no resampling, and so the classifier receives the data as
%   it was collected from the individual matrices.
%   1: Within each iteration, trials are mixed randomly. For example, in
%   the mixed matrix, one column might contains the first trial from neuron
%   1,the second trial from neuron 2, the 10th trial from neuron 3 etc ..
%   data points for a given neuron from a given trial are kept together (i.e. withint he same column
%   of the matrix.
%   1<ResampleN: If ResampleN is larger (and it should be larger than 15 and
%   even)then a matrix with ResampleN columns is created. It will be
%   composed from responses to the two different stimuli, and this is why
%   it has to be even.
%
% Nrepeats: Number of iterations for each classification. In each one, the
%   training and testing sets are selected anew.
%
% MaxEpochs: Maximum number of iterations - relevant for the perceptron
%   classifier, but not for the SVM

% shuffle_method: There are two different kinds of shuffling. One takes
% place before separation of the training and testing sets 
% (so the classifier can learn to "cope" with the disorder), and the other
% type is done only for the test set, (which is expected to confuse the
% classifier more on the test set)
%  The shuffling is generally intended for time sensitive, and not time
%  invariant classification
%  'no_shuffle': do nothing
%  'shuffle_time_before': temporal windows for a given neuron are mixed in
%      the entire data set
%      case 'shuffle_neurons_before': neurons for each temporal window are
%      shuffled in the entire data sets
%
%  These two options above are only intended for time sensitive coding. 
%
%  'all_shuffle': shuffle all windows and neurons within columns the 
%      same re-ordering will be applied to all columns (trials)
%  'shuffle_windows': windows of each neuron are shuffled separately - but data
%      from different neurons is kept separate, the same re-ordering will be applied to all columns (trials)
%  'shuffle_neurons': neuron in each epoch are shuffled separately - but data
%      from different epochs is kept separate
%      the same re-ordering will be applied to all columns (trials)
%  'shift_windows': for each neuron, the windows are shifted by one sample
%      with a "circular" shift (so the last sample replaces the first).
%      The shift is always at a value of 1 (determined by the variable Nshift)
%
% YBS 2017-2018


% This will determine the sampling method
% This code is redundant, but it is maintained for clarity
if ResampleN == 0
    sampling_method = 'standard'; % Take trials as they are
    sampling_str = 'stanard';
elseif ResampleN == 1
    sampling_method = 'mix'; % mix trials across neurons (but keeping data from same neurons together)
    sampling_str = 'mix';
elseif ResampleN > 15 && ~rem(ResampleN,2) 
    sampling_method = 'mix_dup'; % augment the number of trials by making new combinations of stimuli
    sampling_str = ['mix_dup_' num2str(ResampleN)];
end
        
trainfunction = 'trainr'; % training parameters for the perceptron function

% These are the numbers for each of the samples, so, Ntrai amd Ntest must
% be even
Nfortrain = Ntrain/2;
Nfortest  = Ntest/2;


% comparison
switch comparison
    case {'MF', 'MP' , 'FP'}
        datadir = 'C:\Users\yoramb\Documents\DATA\temporal_responses_V2\';
        DO_DURS =  10 * [0.5 1 2 3 4 5 10 20 40];
        MaxTime =  10 * 40;
        % Build the data matrices
        stim_set   = 'MFPC';
    otherwise % This will be for simulated data, in which case the string is the entire directory
        % which has several implications
        datadir = [comparison filesep];
        fileseps = findstr(filesep,comparison);
        comparison = comparison(fileseps(end)+1:end);
        DO_DURS =  10 * [0.5 1 2 3 4 5 10 20];
        MaxTime =  10 * 20;
end

% Define the temporal windows for analysis 
% values are in 10th of seconds because in the file name, the values are 
% multipled by 10 (i.e. 0.5 is written as 5)
for i = 1:length(DO_DURS)   
   DO_STARTS{i}  = [0:DO_DURS(i):MaxTime-DO_DURS(i)];   
end

% special set of windows for the zoom in version
switch comparison
    case {'MF', 'MP' , 'FP'}
        switch class_method
            case 'time invariant'
                DO_DURS   =  10 * [0.5 1 2 3 4 5 10 20 40];
                %DO_DURS   =  10 * [40];
                MaxTime   =  10 * 40;
                STEPSIZE  =  10 * 0.5;
                for i = 1:length(DO_DURS)
                    DO_STARTS{i}  = [0:STEPSIZE:MaxTime-DO_DURS(i)];
                end
            case 'time invariant more'
                DO_DURS   =  10 * [0.5 1:15 20];
                MaxTime   =  10 * 40;
                STEPSIZE  =  10 * 0.5;
                for i = 1:length(DO_DURS)
                    DO_STARTS{i}  = [0:STEPSIZE:MaxTime-DO_DURS(i)];
                end
            case 'time invariant more20'
                DO_DURS   =  10 * [0.5 1:15 20];
                MaxTime   =  10 * 20;
                STEPSIZE  =  10 * 0.5;
                for i = 1:length(DO_DURS)
                    DO_STARTS{i}  = [0:STEPSIZE:MaxTime-DO_DURS(i)];
                end
        end
end
  
% comparison
switch comparison       
    case 'MF'
        F1 = dir([datadir 'NOV_DATASET' stim_set '_STIMMALE*.mat' ]);
        F2 = dir([datadir 'NOV_DATASET' stim_set '_STIMFEMALE*.mat' ]);            
    case 'MP'
        F1 = dir([datadir 'NOV_DATASET' stim_set '_STIMMALE*.mat' ]);
        F2 = dir([datadir 'NOV_DATASET' stim_set '_STIMPRED*.mat' ]);
    case 'FP'
        F1 = dir([datadir 'NOV_DATASET' stim_set '_STIMFEMALE*.mat' ]);
        F2 = dir([datadir 'NOV_DATASET' stim_set '_STIMPRED*.mat' ]); 
    otherwise % simulated data
        F1 = dir([datadir 'stimA_*.mat' ]);
        F2 = dir([datadir 'stimB_*.mat' ]);
end


% Get the file names that correspond to the specified stimulus groups
F1names = {F1.name};
F2names = {F2.name};

% Run over alkl durations
for wli = 1:length(DO_DURS)    
    
    % We need to concatanate values from the different windows, which
    % results in different population sizes for different resolutions
    thisdur = DO_DURS(wli);
    % The big matrices will store data from different time points (when this is applicable)
    % In these matrices, columns correspond to trials, while rows
    % repreented neuron x time point combinations. 
    % for example: if we have 10 neurons and 7 time points, and 12 trials,
    % the final matrix will be 70 X 12
    % the first 10 rows will be from time point 1, the next 10 from time
    % point 2 etc ...
    bigF1mat = [];
    bigF2mat = [];
    randF1mat = [];
    randF2mat = [];
    
    % We need to keep track of these for the shuffling later
    unitinds = [];
    timewindinds = [];
    
    % keep track of these for the time invariant
    trial_inds  = [];
    window_inds = [];
    
    
    % Go over all starting windows
    for dsi = 1:length(DO_STARTS{wli})
                
        % The string that dentifies all files with this start time and
        % duration
        durpattern = ['START' num2str(DO_STARTS{wli}(dsi)) '_DUR' num2str(thisdur) '_'];
        
        % Find file names that correspond to this start and duration for
        % first stim
        F1windowmatches = strfind(F1names,durpattern);
        relF1inds = [];
        for wlifni = 1:length(F1windowmatches)
            tmp = F1windowmatches{wlifni};
            if length(tmp) == 1
                relF1inds = [relF1inds wlifni];
            elseif length(tmp) > 1                            
                disp('invalid number of files found')
                return
            end
        end
        
        % Find file names that correspond to this start and duration for
        % second stim
        F2windowmatches = strfind(F2names,durpattern);
        relF2inds = [];
        for wlifni = 1:length(F2windowmatches)
            tmp = F2windowmatches{wlifni};
            if length(tmp) == 1
                relF2inds = [relF2inds wlifni];
            elseif length(tmp) > 1                            
                disp('invalid number of files found')
                return
            end
        end
                
        % load data from each of the files 
        % concatenate all matching files (these are files within the same stimulus groups and different concentrations)
        F1mat = [];
        for fi = 1:length(relF1inds)
            tmpfname = [datadir F1(relF1inds(fi)).name];
            tmp      = load(tmpfname);
            tmp_mat  = tmp.resp_mat;            
            F1mat    = [F1mat tmp_mat];
        end
                        
        F2mat = [];
        for fi = 1:length(relF2inds)
            tmpfname = [datadir F2(relF1inds(fi)).name];
            tmp      = load(tmpfname);
            tmp_mat  = tmp.resp_mat;
            F2mat    = [F2mat tmp_mat];
        end
        
        % Combine data from different time resolutions 
        % The only difference between the time sensitive vs time invariant
        % is whether different time points are kept separate (so that the number of rows increases)
        % or whether they are treated as different instances of the same
        % thing (so that the number of columns increases)
        switch class_method
            case 'time sensitive'
                bigF1mat = [bigF1mat ; F1mat];
                bigF2mat = [bigF2mat ; F2mat];
            case {'time invariant','time invariant more','time invariant more20'}
                bigF1mat = [bigF1mat  F1mat];
                bigF2mat = [bigF2mat  F2mat];
        end
                
                
    
        % keep track of the units and time windows for the temporal sensitive
        unitinds     = [unitinds 1:size(F1mat,1)];
        % keep track of the temporal windows used (essentially the latencies, since all durations are the same)        
        timewindinds = [timewindinds dsi * ones(1,size(F1mat,1))];
        
        % keep track for the temporal invariant
        trial_inds  = [trial_inds 1:size(F1mat,2)];
        window_inds = [window_inds dsi * ones(1,size(F1mat,2))];

    end % over the different lags for a given duration
          
    
    switch shuffle_method
        case 'shuffle_time_before'
            % shuffle all time windows of each neuron for each trial
            un_units = unique(unitinds);
            for neuron_ind = 1:length(un_units)
                % find indices that are of this window
                rel_win_inds = find(unitinds == neuron_ind);
                thisn = length(rel_win_inds); % This will be equal to the number of different windows (for each neuron)
                
                % For each trial, we randomly mix windows from each neuron
                for BFMi = 1:size(bigF1mat,2)
                    rp = randperm(thisn);
                    re_ordered_inds = rel_win_inds(rp);
                    bigF1mat(rel_win_inds,BFMi) = bigF1mat(re_ordered_inds,BFMi);
                end                
                for BFMi = 1:size(bigF2mat,2)
                    rp = randperm(thisn);
                    re_ordered_inds = rel_win_inds(rp);
                    bigF2mat(rel_win_inds,BFMi) = bigF2mat(re_ordered_inds,BFMi);
                end
            end
            
        % Shuffle all neurons within each time window
        case 'shuffle_neurons_before'            
            un_epochs = unique(timewindinds);
            for epoch_ind = 1:length(un_epochs)
                % find indices that are of this window
                rel_unit_inds = find(timewindinds == epoch_ind);
                thisn = length(rel_unit_inds); % This will be equal to the number of different units
                
                % For each trial, we randomly mix windows
                for BFMi = 1:size(bigF1mat,2)
                    rp = randperm(thisn);
                    re_ordered_inds = rel_unit_inds(rp);
                    bigF1mat(rel_unit_inds,BFMi) = bigF1mat(re_ordered_inds,BFMi);
                end
                
                for BFMi = 1:size(bigF2mat,2)
                    rp = randperm(thisn);
                    re_ordered_inds = rel_unit_inds(rp);
                    bigF2mat(rel_unit_inds,BFMi) = bigF2mat(re_ordered_inds,BFMi);
                end
            end
    end
        
     % These will be randomized upon each iteration
    randF1mat = bigF1mat;
    randF2mat = bigF2mat;
    
    % some error checking
    [nvals1, ntrials1] = size(bigF1mat);
    [nvals2, ntrials2] = size(bigF2mat);
    if ntrials1 ~= ntrials2
        disp('error - number of trials for both conditions must be identical')
        return
    end
    if nvals1 ~= nvals2
        disp('error - number of values for both conditions must be identical')
        return
    end
    
    % Classify -repeatedly
    for ri = 1:Nrepeats        
        switch sampling_method % Which is determined by the value of ResmapleN            
            case 'standard'
                switch class_method
                    case 'time sensitive'
                        % We change the trials each time - but all trials remain
                        % together (usually included trials form different experiments)
                        randF1mat = bigF1mat(:,randperm(ntrials1));
                        randF2mat = bigF2mat(:,randperm(ntrials2));
                        % define training and testing set
                        XTR    = [randF1mat(:,1:Nfortrain) randF2mat(:,1:Nfortrain)];
                        TTR    = [zeros(1,Nfortrain)       ones(1,Nfortrain)];
                        XTST   = [randF1mat(:,Nfortrain+1:Nfortrain+Nfortest) randF2mat(:,Nfortrain+1:Nfortrain+Nfortest)];
                        TTST   = [zeros(1,Nfortest)                           ones(1,Nfortest)];
                    case {'time invariant','time invariant more','time invariant more20'}
                        % We change the trials each time - but all trials remain
                        % together (usually included trials form different experiments)
                        
                        un_trials = unique(trial_inds);
                                        
                        randF1mat = zeros(size(bigF1mat,1),length(un_trials));
                        randF2mat = zeros(size(bigF2mat,1),length(un_trials));
                        
                        clear this_relF1_window
                        clear this_relF2_window
                        
                        un_trials1 = un_trials(randperm(length(un_trials))); 
                        un_trials2 = un_trials(randperm(length(un_trials)));

                        % The procedure here is more complicated                       
                        for trialind = 1:length(un_trials1)
                            
                            thisT1 = un_trials1(trialind);
                            thisT2 = un_trials2(trialind);
                            
                            % find indices that correspond to this trial
                            % all of these are different windows from the
                            % same trial
                            % choose one of these for F1
                            these_rel_windows1 = find(trial_inds == thisT1);
                            randF1VAL = unidrnd(length(these_rel_windows1));
                            this_relF1_window(trialind) = these_rel_windows1(randF1VAL);
                            randF1mat(:,trialind) = bigF1mat(:,this_relF1_window(trialind));
                            
                             % choose one of these for F2
                            these_rel_windows2 = find(trial_inds == thisT2);
                            randF2VAL = unidrnd(length(these_rel_windows2));
                            this_relF2_window(trialind) = these_rel_windows2(randF2VAL);
                            randF2mat(:,trialind) = bigF2mat(:,this_relF2_window(trialind));
                            
                            
                            % This is kind of an error checking that can be
                            % run to check that everything workds
                            % there should be no overlap of trial indices,
                            % but it is reasonbale to have some overlap in
                            % the window inds, which are chosen
                            % independently for each case separately
                            utr1 = unique(trial_inds(this_relF1_window));
                            uwin1 = unique(window_inds(this_relF1_window));
                            utr2 = unique(trial_inds(this_relF2_window));
                            uwin2 = unique(window_inds(this_relF2_window));
                            
                            % choose one such randomly - this ensure that
                            % the same trial will be represented only once
                        end
                           
                        
                        % define training and testing set
                        XTR    = [randF1mat(:,1:Nfortrain) randF2mat(:,1:Nfortrain)];
                        TTR    = [zeros(1,Nfortrain)       ones(1,Nfortrain)];
                        XTST   = [randF1mat(:,Nfortrain+1:Nfortrain+Nfortest) randF2mat(:,Nfortrain+1:Nfortrain+Nfortest)];
                        TTST   = [zeros(1,Nfortest)                           ones(1,Nfortest)];
                        
                end
                % Resample to generate new combinations of trials
            case 'mix'
                % This is a bit different for the temporal invariant and
                % temporal sensitive
                switch class_method
                    case 'time sensitive' % here we have to keep track of the neurons in question
                        neuron_ids  = unique(unitinds);
                        for neuronind = 1:length(neuron_ids)
                            rel_rows = find(unitinds == neuronind);
                            % draw a random permutation of the total number of trials
                            thisrandperm = randperm(size(bigF1mat,2));
                            % now assigm the trials
                            randF1mat(rel_rows,:) = bigF1mat(rel_rows,thisrandperm);
                            % draw a random permutation of the total number of trials
                            thisrandperm = randperm(size(bigF2mat,2));
                            % now assigm the trials
                            randF2mat(rel_rows,:) = bigF2mat(rel_rows,thisrandperm);
                        end
                    case {'time invariant','time invariant more','time invariant more20'} % here we jsut shuffle all the rows
                        for neuronind = 1:size(bigF1mat,1)
                            % draw a random permutation of the total number of trials
                            thisrandperm = randperm(size(bigF1mat,2));
                            % now assigm the trials
                            randF1mat(neuronind,:) = bigF1mat(neuronind,thisrandperm);
                            % draw a random permutation of the total number of trials
                            thisrandperm = randperm(size(bigF2mat,2));
                            % now assigm the trials
                            randF2mat(neuronind,:) = bigF2mat(neuronind,thisrandperm);
                        end                        
                end                
                % now define the test and train sets
                XTR    = [randF1mat(:,1:Nfortrain) randF2mat(:,1:Nfortrain)];
                TTR    = [zeros(1,Nfortrain)       ones(1,Nfortrain)];                
                XTST   = [randF1mat(:,Nfortrain+1:Nfortrain+Nfortest) randF2mat(:,Nfortrain+1:Nfortrain+Nfortest)];
                TTST   = [zeros(1,Nfortest)                           ones(1,Nfortest)];
                                
            case 'mix_dup'
                 % This is a bit different for the temporal invariant and
                % temporal sensitive
                switch class_method
                    case 'time sensitive' % here we have to keep track of the neurons in question
                        neuron_ids  = unique(unitinds);
                        for neuronind = 1:length(neuron_ids)
                            rel_rows = find(unitinds == neuronind);
                            % draw a random permutation of the total number of trials
                            thisrandperm = randperm(size(bigF1mat,2));
                            % now assigm the trials
                            randF1mat(rel_rows,:) = bigF1mat(rel_rows,thisrandperm);
                            % draw a random permutation of the total number of trials
                            thisrandperm = randperm(size(bigF2mat,2));
                            % now assigm the trials
                            randF2mat(rel_rows,:) = bigF2mat(rel_rows,thisrandperm);
                        end
                    case {'time invariant','time invariant more','time invariant more20'} % here we jsut shuffle all the rows
                        for neuronind = 1:size(bigF1mat,1)
                            % draw a random permutation of the total number of trials
                            thisrandperm = randperm(size(bigF1mat,2));
                            % now assigm the trials
                            randF1mat(neuronind,:) = bigF1mat(neuronind,thisrandperm);
                            % draw a random permutation of the total number of trials
                            thisrandperm = randperm(size(bigF2mat,2));
                            % now assigm the trials
                            randF2mat(neuronind,:) = bigF2mat(neuronind,thisrandperm);
                        end
                end
                
                % separate the training and test matrices
                XTST   = [randF1mat(:,Nfortrain+1:Nfortrain+Nfortest) randF2mat(:,Nfortrain+1:Nfortrain+Nfortest)];
                TTST   = [zeros(1,Nfortest) ones(1,Nfortest)];
                
                baseXTR1    = randF1mat(:,1:Nfortrain); 
                baseXTR2    = randF2mat(:,1:Nfortrain); 
                                
                % now artificially increase each data set
                PsNtrain = ResampleN/2;  
                % initialize thed matrices
                pseudo_XTR1 = zeros(size(baseXTR1,1),PsNtrain);
                pseudo_XTR2 = zeros(size(baseXTR2,1),PsNtrain);                
                    
                % This row indexing depends on the type of approach used
                 switch class_method
                    case 'time sensitive' % here we have to keep track of the neurons in question                      
                        neuron_ids  = unique(unitinds);
                        for PsNtrainInd = 1:PsNtrain
                            for neuronind = 1:length(neuron_ids)
                                rel_rows = find(unitinds == neuronind);
                                % pick a random trial number for the first part of the training data
                                randtrial = unidrnd(size(baseXTR1,2));
                                pseudo_XTR1(rel_rows,PsNtrainInd) = baseXTR1(rel_rows,randtrial);
                                % pick a random trial number for the second part of
                                % the training data
                                randtrial = unidrnd(size(baseXTR2,2));
                                pseudo_XTR2(rel_rows,PsNtrainInd) = baseXTR2(rel_rows,randtrial);
                            end
                        end
                     case {'time invariant','time invariant more','time invariant more20'} % here we jsut shuffle the values in each row 
                         for PsNtrainInd = 1:PsNtrain
                             for neuronind = 1:size(baseXTR1,1)
                                 % pick a random trial number for the first part of the training data
                                 randtrial = unidrnd(size(baseXTR1,2));
                                 pseudo_XTR1(neuronind,PsNtrainInd) = baseXTR1(neuronind,randtrial);
                                 % pick a random trial number for the second part of
                                 % the training data
                                 randtrial = unidrnd(size(baseXTR2,2));
                                 pseudo_XTR2(neuronind,PsNtrainInd) = baseXTR2(neuronind,randtrial);
                             end
                         end
                 end
                 
                
                % Now create the composite matrices
                XTR    = [pseudo_XTR1            pseudo_XTR2];
                TTR    = [zeros(1,PsNtrain) ones(1,PsNtrain)];
                
        end
                 
        % Shuffling can also be performed at this stage - after the
        % training and testing matrices have been separated
        switch shuffle_method
            
            case 'no_shuffle'  % do nothing
            case 'all_shuffle'
                % shuffle all windows and neurons
                % the same re-ordering will be applied to all columns (trials)
                thisn = size(XTST,1); % number of neurons X data points
                re_ordered_inds = randperm(thisn);
                XTST = XTST(re_ordered_inds,:);
            case 'shuffle_windows'
                % windows of each neuron are shuffled separately - but data
                % from different neurons is kept separate
                % the same re-ordering will be applied to all columns (trials)
                un_units = unique(unitinds);
                for neuron_ind = 1:length(un_units)
                    % find indices that are of this window
                    rel_win_inds = find(unitinds == neuron_ind);
                    thisn = length(rel_win_inds);
                    re_ordered_inds = rel_win_inds(randperm(thisn));
                    XTST(rel_win_inds,:) = XTST(re_ordered_inds,:);
                end
            case 'shuffle_neurons'
                % neuron in each epoch are shuffled separately - but data
                % from different epochs is kept separate
                % the same re-ordering will be applied to all columns (trials)
                un_epochs = unique(timewindinds);
                for epoch_ind = 1:length(un_epochs)
                    % find indices that are of this window
                    rel_unit_inds = find(timewindinds == epoch_ind);
                    thisn = length(rel_unit_inds); % This will be equal to the number of different units
                    re_ordered_inds = rel_unit_inds(randperm(thisn));
                    XTST(rel_unit_inds,:) = XTST(re_ordered_inds,:);
                end
            case 'shift_windows'
                % shift all neurons (in register) by one time frame
                Nshift = 1;
                un_units = unique(unitinds);
                for neuron_ind = 1:length(un_units)
                    % find indices that are of this window
                    rel_win_inds = find(unitinds == neuron_ind);
                    thisn = length(rel_win_inds);
                    re_ordered_inds = circshift(rel_win_inds,Nshift);
                    XTST(rel_win_inds,:) = XTST(re_ordered_inds,:);
                end
    end
    
        % now classify
        switch classifier_type
            case 'PERC'
                [~,PC(wli,ri),~,~] = NOV_train_perceptron_temporal_analysis(XTR,XTST,TTR,TTST,MaxEpochs,trainfunction,[]);
            case 'SVM'
                [~,PC(wli,ri)] = NOV_train_SVM_temporal_analysis(XTR,XTST,TTR,TTST,'Quadratic');
        end        
    end    
end


fname = ['new_' class_method '_' classifier_type '_' comparison '_Ntr_' num2str(Ntrain) '_Ntst_' num2str(Ntest) '_' sampling_str '_' shuffle_method '_reps_' num2str(Nrepeats) '_MaxEpochs_' num2str(MaxEpochs)];

fullfname = [datadir fname];
% save classificaiton results data
save(fullfname);

        
%derive mean values and plot them
mean_perf = mean(PC,2);
std_perf = std(PC,0,2);
ste_perf = std_perf/sqrt(Nrepeats);

figure;
set(gcf,'name',fname)
bar(mean_perf);
set(gca,'ylim',[45 100]);
set(gca,'xtick',[1:length(DO_DURS)],'xticklabel',num2str(DO_DURS'/10))
for i = 1:length(mean_perf)
    lh = line(i*[1 1],[mean_perf(i)-ste_perf(i) mean_perf(i)+ste_perf(i)]);
    set(lh,'color','r','linewidth',2)
end
xlabel('window size')
ylabel('percent correct')
savefig(fullfname)

return
